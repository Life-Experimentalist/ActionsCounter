# ActionsCounter Dual Mode Workflow
# Supports both manual workflow_dispatch and webhook repository_dispatch
#
# VALIDATION NOTES:
# - "Context access might be invalid" errors for secrets are expected
# - These will resolve once the workflow is deployed to a GitHub repository
# - Required secrets: ADMIN_PASSWORD, PAT_TOKEN, DB_* (for database mode)
# - Required variables: STORAGE_MODE (repository variable, not secret)
#
name: "Handle Projects"

# NOTE: The lint errors about "Context access might be invalid" for secrets are expected
# when no GitHub repository exists yet. These will resolve once the workflow is deployed
# to an actual GitHub repository with the required secrets configured.

on:
    repository_dispatch:
        types: [ping, increment, decrement, add, remove, set, get, list]
    workflow_dispatch:
        inputs:
            action:
                description: |
                    Action to perform. Options:
                      - increment: Increase the count for a project by 1 (creates project if not exists)
                      - decrement: Decrease the count for a project by 1 (minimum 0)
                      - add: Add a new project with description and URL
                      - remove: Delete a project and all its data
                      - list: List all projects with details
                      - get: Get details for a specific project
                      - set: Edit any detail of a project (name, description, url, count, etc.) including renaming the project
                required: true
                default: "add"
                type: choice
                options:
                    - increment
                    - decrement
                    - add
                    - remove
                    - list
                    - get
                    - set
            project_name:
                description: "Current project name (required for increment/decrement/add/remove/get/set)"
                required: false
                type: string
            new_name:
                description: "New project name (for set action, to rename the project)"
                required: false
                type: string
            description:
                description: "Project description (optional for add/set action)"
                required: false
                type: string
            url:
                description: "Project URL (optional for add/set action)"
                required: false
                type: string
            count_value:
                description: "Count value (optional for set action)"
                required: false
                type: number
            password:
                description: "Password for authentication"
                required: true
                type: string

jobs:
    handle-projects:
        runs-on: ubuntu-latest
        steps:
            - name: Set Input Variables
              id: inputs
              run: |
                  # Handle inputs from both repository_dispatch and workflow_dispatch
                  if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
                    # Repository dispatch (webhook) inputs
                    ACTION="${{ github.event.action }}"
                    PROJECT_ALIAS="${{ github.event.client_payload.project_alias }}"
                    PROJECT_NAME="${{ github.event.client_payload.project_name }}"
                    DESCRIPTION="${{ github.event.client_payload.description }}"
                    URL="${{ github.event.client_payload.url }}"
                    COUNT_VALUE="${{ github.event.client_payload.count_value }}"
                    # Admin password comes from repository secrets (secure)
                    PASSWORD="${{ secrets.ADMIN_PASSWORD }}"
                  else
                    # Workflow dispatch (manual UI) inputs
                    ACTION="${{ github.event.inputs.action }}"
                    PROJECT_NAME="${{ github.event.inputs.project_name }}"
                    NEW_NAME="${{ github.event.inputs.new_name }}"
                    DESCRIPTION="${{ github.event.inputs.description }}"
                    URL="${{ github.event.inputs.url }}"
                    COUNT_VALUE="${{ github.event.inputs.count_value }}"
                    PASSWORD="${{ github.event.inputs.password }}"
                  fi

                  echo "action=$ACTION" >> $GITHUB_OUTPUT
                  echo "project_name=$PROJECT_NAME" >> $GITHUB_OUTPUT
                  echo "new_name=$NEW_NAME" >> $GITHUB_OUTPUT
                  echo "description=$DESCRIPTION" >> $GITHUB_OUTPUT
                  echo "url=$URL" >> $GITHUB_OUTPUT
                  echo "count_value=$COUNT_VALUE" >> $GITHUB_OUTPUT
                  echo "password=$PASSWORD" >> $GITHUB_OUTPUT

                  echo "--- Workflow Input Variables ---"
                  echo "Action: $ACTION"
                  echo "Project Name: $PROJECT_NAME"
                  echo "New Name: $NEW_NAME"
                  echo "Description: $DESCRIPTION"
                  echo "URL: $URL"
                  echo "Count Value: $COUNT_VALUE"
                  echo "Password: $PASSWORD"
                  echo "Event type: ${{ github.event_name }}"
                  echo "--------------------------------"

            - name: Determine Storage Mode
              id: mode
              run: |
                  # Try to get storage mode from repository variables first, fallback to secrets
                  STORAGE_MODE=""

                  # Check GitHub Repository Variables
                  response=$(curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
                    -H "Accept: application/vnd.github+json" \
                    "https://api.github.com/repos/${{ github.repository }}/actions/variables/STORAGE_MODE" || echo "")

                  # Print the raw response for debugging
                  echo "Raw STORAGE_MODE response: $response"

                  if echo "$response" | grep -q '"value"'; then
                    # Use jq for robust extraction
                    STORAGE_MODE=$(echo "$response" | jq -r '.value // empty')
                    echo "üìä Storage mode from repository variables: $STORAGE_MODE"
                  fi

                  if [ -z "$STORAGE_MODE" ]; then
                    STORAGE_MODE="1"
                    echo "üìä Storage mode from fallback: $STORAGE_MODE"
                    # Create repository variable if it doesn't exist
                    if [ -n "$STORAGE_MODE" ]; then
                      curl -X POST \
                        -H "Accept: application/vnd.github+json" \
                        -H "Authorization: Bearer ${{ secrets.PAT_TOKEN }}" \
                        -H "X-GitHub-Api-Version: 2022-11-28" \
                        "https://api.github.com/repos/${{ github.repository }}/actions/variables" \
                        -d "{\"name\":\"STORAGE_MODE\",\"value\":\"$STORAGE_MODE\"}" || echo "Could not create STORAGE_MODE variable"
                    fi
                  fi

                  # Map storage modes: 1=github_variables, 2=database, 3=repository_commits
                  case "$STORAGE_MODE" in
                    "1")
                      echo "mode=github_variables" >> $GITHUB_OUTPUT
                      echo "üîó Using GITHUB VARIABLES storage mode"
                      ;;
                    "2")
                      echo "mode=database" >> $GITHUB_OUTPUT
                      echo "üóÑÔ∏è Using DATABASE storage mode"
                      ;;
                    "3")
                      echo "mode=repository_commits" >> $GITHUB_OUTPUT
                      echo "üìÅ Using REPOSITORY COMMITS storage mode"
                      ;;
                    *)
                      echo "mode=github_variables" >> $GITHUB_OUTPUT
                      echo "üîó Using GITHUB VARIABLES storage mode (default)"
                      ;;
                  esac

              # NOTE: When entering secrets or variables in the GitHub UI, do NOT use double quotes. Enter the value as plain text (e.g., 2 not "2"). Quotes are not required and will be treated as part of the value.

            - name: Validate authentication
              run: |
                  # For webhook calls (repository_dispatch), validate project auth token
                  # For manual calls (workflow_dispatch), validate admin password
                  if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
                    PROJECT_ALIAS="${{ steps.inputs.outputs.project_alias }}"
                    AUTH_TOKEN="${{ github.event.client_payload.auth_token || '' }}"
                    if [ -n "$PROJECT_ALIAS" ] && [ -n "$AUTH_TOKEN" ]; then
                      echo "‚úÖ Repository dispatch with project alias: $PROJECT_ALIAS"

                      # Validate project alias format
                      if [[ "$PROJECT_ALIAS" =~ ^proj_[a-z0-9]+$ ]]; then
                        echo "‚úÖ Valid project alias format"

                        # Hash the provided auth token
                        AUTH_HASH_INPUT=$(echo -n "$AUTH_TOKEN" | sha256sum | awk '{print $1}')

                        if [ "${{ steps.mode.outputs.mode }}" = "database" ]; then
                          # DATABASE MODE: existing validation code...
                          export PGPASSWORD="${{ secrets.DB_PASS }}"
                          STORED_HASH=$(psql -h "${{ secrets.DB_HOST }}" -p "${{ secrets.DB_PORT }}" -U "${{ secrets.DB_USER }}" -d "${{ secrets.DB_NAME }}" -t -c "
                            SELECT auth_hash FROM ${{ secrets.DB_SCHEMA }}.projects WHERE alias = '$PROJECT_ALIAS';
                          " | xargs)
                          if [ -z "$STORED_HASH" ]; then
                            echo "‚ùå Project alias not found in database"
                            exit 1
                          fi
                          if [ "$AUTH_HASH_INPUT" != "$STORED_HASH" ]; then
                            echo "‚ùå Invalid project auth token (hash mismatch)"
                            exit 1
                          fi
                          echo "üîê Project authenticated successfully (database mode)"
                        elif [ "${{ steps.mode.outputs.mode }}" = "github_variables" ]; then
                          # GitHub Variables mode: fetch and check auth_hash
                          response=$(curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
                            -H "Accept: application/vnd.github+json" \
                            "https://api.github.com/repos/${{ github.repository }}/actions/variables/PROJECTS_DATA" || echo "")
                          ENCODED_DATA=$(echo "$response" | grep -o '"value":"[^\"]*"' | cut -d'"' -f4)
                          PROJECTS_JSON=$(echo "$ENCODED_DATA" | base64 -d 2>/dev/null || echo "$ENCODED_DATA" | sed 's/\\"/"/g')
                          STORED_HASH=$(echo "$PROJECTS_JSON" | jq -r --arg alias "$PROJECT_ALIAS" '.projects | to_entries[] | select(.value.alias == $alias) | .value.auth_hash')
                          if [ -z "$STORED_HASH" ] || [ "$STORED_HASH" = "null" ]; then
                            echo "‚ùå Project alias not found in GitHub Variables"
                            exit 1
                          fi
                          if [ "$AUTH_HASH_INPUT" != "$STORED_HASH" ]; then
                            echo "‚ùå Invalid project auth token (hash mismatch)"
                            exit 1
                          fi
                          echo "üîê Project authenticated successfully (github_variables mode)"
                        else
                          echo "‚ö†Ô∏è Auth check for this mode not implemented, only format validated"
                        fi
                      else
                        echo "‚ùå Invalid project alias format"
                        exit 1
                      fi
                    else
                      echo "‚ùå Project alias or auth token missing for webhook"
                      exit 1
                    fi
                  else
                    # Manual workflow dispatch - validate admin password
                    if [ "${{ steps.inputs.outputs.password }}" != "${{ secrets.ADMIN_PASSWORD }}" ]; then
                      echo "‚ùå Invalid admin password"
                      exit 1
                    fi
                    echo "‚úÖ Admin password validated"
                  fi

            - name: Resolve Project Name from Alias
              if: github.event_name == 'repository_dispatch'
              id: resolve
              run: |
                  # In production, this would query a secure mapping of aliases to project names
                  # For now, we extract from the alias or use a placeholder
                  PROJECT_ALIAS="${{ steps.inputs.outputs.project_alias }}"
                  echo "üîç Resolving project alias: $PROJECT_ALIAS"

                  # TODO: Implement secure alias-to-name resolution
                  # This would typically involve:
                  # 1. Querying encrypted project mappings from repository variables
                  # 2. Validating the auth token against the project
                  # 3. Returning the actual project name

                  # For now, extract a placeholder project name
                  RESOLVED_NAME="project_${PROJECT_ALIAS#proj_}"
                  echo "resolved_project_name=$RESOLVED_NAME" >> $GITHUB_OUTPUT
                  echo "‚úÖ Resolved to project: $RESOLVED_NAME"

            # DATABASE MODE JOBS
            - name: Setup Database Mode
              if: steps.mode.outputs.mode == 'database'
              run: |
                  sudo apt-get update
                  sudo apt-get install -y postgresql-client
                  echo "‚úÖ PostgreSQL client installed"

            - name: Database - Debug DB Secrets
              if: steps.mode.outputs.mode == 'database'
              run: |
                  export DB_HOST="${{ secrets.DB_HOST }}"
                  export DB_PORT="${{ secrets.DB_PORT }}"
                  export DB_USER="${{ secrets.DB_USER }}"
                  export DB_PASS="${{ secrets.DB_PASS }}"
                  export DB_NAME="${{ secrets.DB_NAME }}"
                  export DB_SCHEMA="${{ secrets.DB_SCHEMA }}"

                  echo "DB_HOST=$DB_HOST"
                  echo "DB_PORT=$DB_PORT"
                  echo "DB_USER=$DB_USER"
                  echo "DB_PASS=$DB_PASS"
                  echo "DB_NAME=$DB_NAME"
                  echo "DB_SCHEMA=$DB_SCHEMA"
                  # Check for missing secrets
                  missing=0
                  for var in DB_HOST DB_PORT DB_USER DB_PASS DB_NAME DB_SCHEMA; do
                    value="$(eval echo \$$var)"
                    if [ -z "$value" ]; then
                      echo "‚ùå $var is missing or not set!"
                      missing=1
                    fi
                  done
                  if [ "$missing" = "1" ]; then
                    echo "‚ùå One or more DB secrets are missing. Aborting."
                    exit 1
                  fi

            - name: Database - Initialize Schema
              if: steps.mode.outputs.mode == 'database'
              run: |
                  export PGPASSWORD="${{ secrets.DB_PASS }}"

                  # Create schema if not exists
                  psql -h "${{ secrets.DB_HOST }}" -p "${{ secrets.DB_PORT }}" -U "${{ secrets.DB_USER }}" -d "${{ secrets.DB_NAME }}" -c "
                    CREATE SCHEMA IF NOT EXISTS ${{ secrets.DB_SCHEMA }};
                  "

                  # Create projects table if not exists, with all required columns
                  psql -h "${{ secrets.DB_HOST }}" -p "${{ secrets.DB_PORT }}" -U "${{ secrets.DB_USER }}" -d "${{ secrets.DB_NAME }}" -c "
                    CREATE TABLE IF NOT EXISTS ${{ secrets.DB_SCHEMA }}.projects (
                      id SERIAL PRIMARY KEY,
                      name VARCHAR(255) UNIQUE NOT NULL,
                      description TEXT,
                      url TEXT,
                      alias VARCHAR(64) UNIQUE NOT NULL,
                      auth_hash TEXT NOT NULL,
                      count INTEGER DEFAULT 0,
                      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    );
                  "

                  echo "‚úÖ Database schema initialized with url, alias, and auth_hash columns"

            - name: Database - Handle Operations
              if: steps.mode.outputs.mode == 'database'
              run: |
                  export PGPASSWORD="${{ secrets.DB_PASS }}"

                  # Determine project name based on event type
                  if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
                    PROJECT_NAME="${{ steps.resolve.outputs.resolved_project_name }}"
                    echo "üîó Using resolved project name: $PROJECT_NAME"
                  else
                    PROJECT_NAME="${{ github.event.inputs.project_name }}"
                    echo "üìù Using manual project name: $PROJECT_NAME"
                  fi

                  # Save before state for comparison
                  BEFORE_ROWS=$(psql -h "${{ secrets.DB_HOST }}" -p "${{ secrets.DB_PORT }}" -U "${{ secrets.DB_USER }}" -d "${{ secrets.DB_NAME }}" -t -c "SELECT count(*) FROM ${{ secrets.DB_SCHEMA }}.projects;")
                  BEFORE_PROJECT=$(psql -h "${{ secrets.DB_HOST }}" -p "${{ secrets.DB_PORT }}" -U "${{ secrets.DB_USER }}" -d "${{ secrets.DB_NAME }}" -t -c "SELECT * FROM ${{ secrets.DB_SCHEMA }}.projects WHERE name = '$PROJECT_NAME';")

                  case "${{ steps.inputs.outputs.action }}" in
                    "increment")
                      if [ -z "$PROJECT_NAME" ]; then
                        echo "‚ùå Project name is required for increment action"
                        exit 1
                      fi

                      RESULT=$(psql -h "${{ secrets.DB_HOST }}" -p "${{ secrets.DB_PORT }}" -U "${{ secrets.DB_USER }}" -d "${{ secrets.DB_NAME }}" -t -c "
                        INSERT INTO ${{ secrets.DB_SCHEMA }}.projects (name, count, updated_at)
                        VALUES ('$PROJECT_NAME', 1, CURRENT_TIMESTAMP)
                        ON CONFLICT (name)
                        DO UPDATE SET
                          count = projects.count + 1,
                          updated_at = CURRENT_TIMESTAMP
                        RETURNING count;
                      " | xargs)

                      echo "‚úÖ Project '$PROJECT_NAME' incremented to count: $RESULT"
                      ;;

                    "decrement")
                      if [ -z "${{ github.event.inputs.project_name }}" ]; then
                        echo "‚ùå Project name is required for decrement action"
                        exit 1
                      fi

                      RESULT=$(psql -h "${{ secrets.DB_HOST }}" -p "${{ secrets.DB_PORT }}" -U "${{ secrets.DB_USER }}" -d "${{ secrets.DB_NAME }}" -t -c "
                        UPDATE ${{ secrets.DB_SCHEMA }}.projects
                        SET count = GREATEST(count - 1, 0), updated_at = CURRENT_TIMESTAMP
                        WHERE name = '${{ github.event.inputs.project_name }}'
                        RETURNING count;
                      " | xargs)

                      if [ -z "$RESULT" ]; then
                        echo "‚ùå Project '${{ github.event.inputs.project_name }}' not found"
                        exit 1
                      fi

                      echo "‚úÖ Project '${{ github.event.inputs.project_name }}' decremented to count: $RESULT"
                      ;;

                    "add")
                      if [ -z "${{ github.event.inputs.project_name }}" ]; then
                        echo "‚ùå Project name is required for add action"
                        exit 1
                      fi

                      DESCRIPTION="${{ github.event.inputs.description }}"
                      URL="${{ github.event.inputs.url }}"

                      # Generate random alias and auth_token
                      ALIAS="proj_$(openssl rand -hex 8)"
                      AUTH_TOKEN="pauth_$(openssl rand -hex 12)"
                      AUTH_HASH=$(echo -n "$AUTH_TOKEN" | sha256sum | awk '{print $1}')

                      # Insert project with alias and hashed auth_token
                      psql -h "${{ secrets.DB_HOST }}" -p "${{ secrets.DB_PORT }}" -U "${{ secrets.DB_USER }}" -d "${{ secrets.DB_NAME }}" -c "
                        INSERT INTO ${{ secrets.DB_SCHEMA }}.projects (name, description, url, alias, auth_hash, count)
                        VALUES ('${{ github.event.inputs.project_name }}', '$DESCRIPTION', '$URL', '$ALIAS', '$AUTH_HASH', 0)
                        ON CONFLICT (name) DO NOTHING;
                      "

                      echo "‚úÖ Project '${{ github.event.inputs.project_name }}' added successfully"
                      echo "üîë Project Alias: $ALIAS"
                      echo "üîê Project Auth Token (save this securely, it will not be shown again): $AUTH_TOKEN"
                      ;;

                    "remove")
                      if [ -z "${{ github.event.inputs.project_name }}" ]; then
                        echo "‚ùå Project name is required for remove action"
                        exit 1
                      fi

                      ROWS=$(psql -h "${{ secrets.DB_HOST }}" -p "${{ secrets.DB_PORT }}" -U "${{ secrets.DB_USER }}" -d "${{ secrets.DB_NAME }}" -t -c "
                        DELETE FROM ${{ secrets.DB_SCHEMA }}.projects
                        WHERE name = '${{ github.event.inputs.project_name }}';
                        SELECT ROW_COUNT();
                      " | tail -1 | xargs)

                      if [ "$ROWS" = "0" ]; then
                        echo "‚ùå Project '${{ github.event.inputs.project_name }}' not found"
                        exit 1
                      fi

                      echo "‚úÖ Project '${{ github.event.inputs.project_name }}' removed successfully"
                      ;;

                    "get")
                      if [ -z "${{ github.event.inputs.project_name }}" ]; then
                        echo "‚ùå Project name is required for get action"
                        exit 1
                      fi

                      RESULT=$(psql -h "${{ secrets.DB_HOST }}" -p "${{ secrets.DB_PORT }}" -U "${{ secrets.DB_USER }}" -d "${{ secrets.DB_NAME }}" -t -c "
                        SELECT name, description, url, alias, count, created_at, updated_at
                        FROM ${{ secrets.DB_SCHEMA }}.projects
                        WHERE name = '${{ github.event.inputs.project_name }}';
                      ")

                      if [ -z "$RESULT" ]; then
                        echo "‚ùå Project '${{ github.event.inputs.project_name }}' not found"
                        exit 1
                      fi

                      echo "‚úÖ Project Details:"
                      echo "$RESULT"
                      ;;

                    "set")
                      if [ -z "${{ github.event.inputs.project_name }}" ]; then
                        echo "‚ùå Project name is required for set action"
                        exit 1
                      fi
                      PROJECT_NAME="${{ github.event.inputs.project_name }}"
                      # Check if project exists
                      if ! echo "$PROJECTS_JSON" | jq -e --arg name "$PROJECT_NAME" '.projects[$name]' > /dev/null; then
                        echo "‚ùå Project '$PROJECT_NAME' not found. Cannot set."
                        exit 1
                      fi
                      # If renaming, handle key change
                      if [ -n "${{ github.event.inputs.new_name }}" ] && [ "${{ github.event.inputs.new_name }}" != "$PROJECT_NAME" ]; then
                        NEW_NAME="${{ github.event.inputs.new_name }}"
                        # Copy project, update fields, delete old key, add new key
                        UPDATED_PROJECT=$(echo "$PROJECTS_JSON" | jq --arg name "$PROJECT_NAME" --arg new_name "$NEW_NAME" \
                          '.projects[$name] | .name = $new_name')
                        # Update other fields if provided
                        if [ -n "${{ github.event.inputs.description }}" ]; then
                          UPDATED_PROJECT=$(echo "$UPDATED_PROJECT" | jq --arg desc "${{ github.event.inputs.description }}" '.description = $desc')
                        fi
                        if [ -n "${{ github.event.inputs.url }}" ]; then
                          UPDATED_PROJECT=$(echo "$UPDATED_PROJECT" | jq --arg url "${{ github.event.inputs.url }}" '.url = $url')
                        fi
                        if [ -n "${{ github.event.inputs.count_value }}" ]; then
                          UPDATED_PROJECT=$(echo "$UPDATED_PROJECT" | jq --argjson count "${{ github.event.inputs.count_value }}" '.count = $count')
                        fi
                        UPDATED_PROJECT=$(echo "$UPDATED_PROJECT" | jq '.updated_at = (now | strftime("%Y-%m-%dT%H:%M:%S.%3NZ"))')
                        # Remove old key, add new key
                        NEW_JSON=$(echo "$PROJECTS_JSON" | jq --arg name "$PROJECT_NAME" --arg new_name "$NEW_NAME" --argjson updated "$UPDATED_PROJECT" '
                          .projects |= (del(.[$name]) + {($new_name): $updated}) | {projects: .}
                        ')
                      else
                        # Not renaming, just update fields
                        JQ_FILTER='.projects["'"$PROJECT_NAME"'"]'
                        if [ -n "${{ github.event.inputs.new_name }}" ]; then
                          JQ_FILTER="$JQ_FILTER | .name = \"${{ github.event.inputs.new_name }}\""
                        fi
                        if [ -n "${{ github.event.inputs.description }}" ]; then
                          JQ_FILTER="$JQ_FILTER | .description = \"${{ github.event.inputs.description }}\""
                        fi
                        if [ -n "${{ github.event.inputs.url }}" ]; then
                          JQ_FILTER="$JQ_FILTER | .url = \"${{ github.event.inputs.url }}\""
                        fi
                        if [ -n "${{ github.event.inputs.count_value }}" ]; then
                          JQ_FILTER="$JQ_FILTER | .count = ${{ github.event.inputs.count_value }}"
                        fi
                        # Always update updated_at
                        JQ_FILTER="$JQ_FILTER | .updated_at = (now | strftime(\"%Y-%m-%dT%H:%M:%S.%3NZ\"))"
                        NEW_JSON=$(echo "$PROJECTS_JSON" | jq "$JQ_FILTER" | jq '{projects: .projects}')
                      fi
                      echo "‚úÖ Project '$PROJECT_NAME' updated successfully"
                      PROJECTS_JSON="$NEW_JSON"
                      # After set, compare before/after
                      if diff -q <(cat /tmp/projects_before.json) <(echo "$NEW_JSON") >/dev/null; then
                        echo "‚ùå No change detected in PROJECTS_DATA after set operation"
                        exit 1
                      fi
                      ;;

                    "list")
                      echo "üìä All Projects:"
                      psql -h "${{ secrets.DB_HOST }}" -p "${{ secrets.DB_PORT }}" -U "${{ secrets.DB_USER }}" -d "${{ secrets.DB_NAME }}" -c "
                        SELECT name, alias, count, description, url
                        FROM ${{ secrets.DB_SCHEMA }}.projects
                        ORDER BY count DESC, name ASC;
                      "
                      ;;

                  esac

            # GITHUB VARIABLES MODE JOBS
            - name: GitHub Variables - Ensure Initialization
              if: steps.mode.outputs.mode == 'github_variables'
              run: |
                  echo "üîç Ensuring GitHub Variables are initialized..."
                  # Check and initialize PROJECTS_DATA
                  response=$(curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
                    -H "Accept: application/vnd.github+json" \
                    "https://api.github.com/repos/${{ github.repository }}/actions/variables/PROJECTS_DATA" || echo "")
                  if ! echo "$response" | grep -q '"value"'; then
                    echo "‚ö†Ô∏è PROJECTS_DATA variable missing, initializing..."
                    curl -X POST \
                      -H "Accept: application/vnd.github+json" \
                      -H "Authorization: Bearer ${{ secrets.PAT_TOKEN }}" \
                      -H "X-GitHub-Api-Version: 2022-11-28" \
                      "https://api.github.com/repos/${{ github.repository }}/actions/variables" \
                      -d '{"name":"PROJECTS_DATA","value":"eyJwcm9qZWN0cyI6e319"}' # base64 for {"projects":{}}
                  fi
                  # Check and initialize ANALYTICS_DATA
                  response2=$(curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
                    -H "Accept: application/vnd.github+json" \
                    "https://api.github.com/repos/${{ github.repository }}/actions/variables/ANALYTICS_DATA" || echo "")
                  if ! echo "$response2" | grep -q '"value"'; then
                    echo "‚ö†Ô∏è ANALYTICS_DATA variable missing, initializing..."
                    curl -X POST \
                      -H "Accept: application/vnd.github+json" \
                      -H "Authorization: Bearer ${{ secrets.PAT_TOKEN }}" \
                      -H "X-GitHub-Api-Version: 2022-11-28" \
                      "https://api.github.com/repos/${{ github.repository }}/actions/variables" \
                      -d '{"name":"ANALYTICS_DATA","value":"eyJ0b3RhbF9wcm9qZWN0cyI6MCwidG90YWxfY291bnQiOjAsImF2ZXJhZ2VfY291bnQiOjAsIm1heF9jb3VudCI6MCwibWluX2NvdW50IjowLCJsYXN0X3VwZGF0ZWQiOiIiLCJzdG9yYWdlX21vZGUiOiJnaXRodWJfdmFyaWFibGVzIn0="}' # base64 for minimal analytics
                  fi
                  echo "‚úÖ GitHub Variables initialization complete"

            - name: GitHub Variables - Handle Operations
              if: steps.mode.outputs.mode == 'github_variables'
              run: |
                  echo "üîó Processing GitHub Variables storage operations..."

                  # Get current projects data from GitHub Variables
                  response=$(curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
                    -H "Accept: application/vnd.github+json" \
                    "https://api.github.com/repos/${{ github.repository }}/actions/variables/PROJECTS_DATA" || echo "")

                  echo "--- DEBUG: Raw PROJECTS_DATA variable response ---"
                  echo "$response"

                  if echo "$response" | grep -q '"value"'; then
                    ENCODED_DATA=$(echo "$response" | grep -o '"value":"[^\"]*"' | cut -d'"' -f4)
                    echo "--- DEBUG: Encoded PROJECTS_DATA ---"
                    echo "$ENCODED_DATA"
                    PROJECTS_JSON=$(echo "$ENCODED_DATA" | base64 -d 2>/dev/null | tr -d '\r' | sed '/^$/d' || echo "$ENCODED_DATA" | sed 's/\\"/"/g')
                    echo "--- DEBUG: Decoded PROJECTS_JSON ---"
                    echo "$PROJECTS_JSON"
                    # Ensure PROJECTS_JSON is valid and not empty
                    if [ -z "$PROJECTS_JSON" ] || ! echo "$PROJECTS_JSON" | jq . >/dev/null 2>&1; then
                      echo "‚ö†Ô∏è PROJECTS_DATA missing or invalid, initializing to {\"projects\":{}}"
                      echo "DEBUG: jq error code: $?"
                      echo "DEBUG: Raw decoded PROJECTS_JSON:"
                      echo "$PROJECTS_JSON"
                      PROJECTS_JSON='{"projects":{}}'
                    fi
                  else
                    echo "‚ö†Ô∏è PROJECTS_DATA missing, initializing"
                    PROJECTS_JSON='{"projects":{}}'
                  fi

                  # Save before state for comparison
                  echo "$PROJECTS_JSON" > /tmp/projects_before.json

                  case "${{ github.event.inputs.action }}" in
                    "add")
                      if [ -z "${{ github.event.inputs.project_name }}" ]; then
                        echo "‚ùå Project name is required for add action"
                        exit 1
                      fi
                      PROJECT_NAME="${{ github.event.inputs.project_name }}"
                      DESCRIPTION="${{ github.event.inputs.description }}"
                      URL="${{ github.event.inputs.url }}"

                      # Defensive: ensure .projects exists and is an object
                      if ! echo "$PROJECTS_JSON" | jq -e '.projects | type == "object"' >/dev/null 2>&1; then
                        PROJECTS_JSON=$(echo "$PROJECTS_JSON" | jq '{projects: {}}')
                      fi

                      # Check if project already exists
                      if echo "$PROJECTS_JSON" | jq -e --arg name "$PROJECT_NAME" '.projects[$name]' > /dev/null; then
                        echo "‚ö†Ô∏è Project '$PROJECT_NAME' already exists. Skipping add."
                        exit 0
                      fi

                      # Generate random alias and auth_token
                      ALIAS="proj_$(openssl rand -hex 8)"
                      AUTH_TOKEN="pauth_$(openssl rand -hex 12)"
                      AUTH_HASH=$(echo -n "$AUTH_TOKEN" | sha256sum | awk '{print $1}')

                      sudo apt-get update && sudo apt-get install -y jq
                      NEW_JSON=$(echo "$PROJECTS_JSON" | jq --arg name "$PROJECT_NAME" --arg desc "$DESCRIPTION" --arg url "$URL" --arg alias "$ALIAS" --arg auth_hash "$AUTH_HASH" '
                        .projects[$name] = {
                          "count": 0,
                          "description": $desc,
                          "url": $url,
                          "alias": $alias,
                          "auth_hash": $auth_hash,
                          "created_at": (now | strftime("%Y-%m-%dT%H:%M:%S.%3NZ")),
                          "updated_at": (now | strftime("%Y-%m-%dT%H:%M:%S.%3NZ"))
                        } | {projects: .projects}
                      ')

                      echo "--- DEBUG: Before add ---"
                      cat /tmp/projects_before.json
                      echo "--- DEBUG: After add ---"
                      echo "$NEW_JSON"

                      # After add, compare before/after
                      if diff -q <(cat /tmp/projects_before.json) <(echo "$NEW_JSON") >/dev/null; then
                        echo "‚ö†Ô∏è No change detected in PROJECTS_DATA after add operation (project may already exist or no-op)."
                        exit 0
                      fi

                      echo "‚úÖ Project '$PROJECT_NAME' added successfully"
                      echo "üîë Project Alias: $ALIAS"
                      echo "üîê Project Auth Token (save this securely, it will not be shown again): $AUTH_TOKEN"
                      PROJECTS_JSON="$NEW_JSON"
                      ;;

                    "increment")
                      if [ -z "${{ github.event.inputs.project_name }}" ]; then
                        echo "‚ùå Project name is required for increment action"
                        exit 1
                      fi

                      PROJECT_NAME="${{ github.event.inputs.project_name }}"
                      # Check if project exists
                      if ! echo "$PROJECTS_JSON" | jq -e --arg name "$PROJECT_NAME" '.projects[$name]' > /dev/null; then
                        echo "‚ùå Project '$PROJECT_NAME' not found. Cannot increment."
                        exit 1
                      fi

                      # Update count using jq
                      sudo apt-get update && sudo apt-get install -y jq
                      NEW_JSON=$(echo "$PROJECTS_JSON" | jq --arg name "$PROJECT_NAME" '
                        .projects[$name] //= {"count": 0, "created_at": now | strftime("%Y-%m-%dT%H:%M:%S.%3NZ"), "updated_at": now | strftime("%Y-%m-%dT%H:%M:%S.%3NZ")} |
                        .projects[$name].count += 1 |
                        .projects[$name].updated_at = (now | strftime("%Y-%m-%dT%H:%M:%S.%3NZ"))
                        | {projects: .projects}
                      ')

                      NEW_COUNT=$(echo "$NEW_JSON" | jq -r --arg name "$PROJECT_NAME" '.projects[$name].count')
                      echo "‚úÖ Project '$PROJECT_NAME' incremented to count: $NEW_COUNT"
                      PROJECTS_JSON="$NEW_JSON"
                      # After increment, compare before/after
                      if diff -q <(cat /tmp/projects_before.json) <(echo "$NEW_JSON") >/dev/null; then
                        echo "‚ùå No change detected in PROJECTS_DATA after increment operation"
                        exit 1
                      fi
                      ;;

                    "decrement")
                      if [ -z "${{ github.event.inputs.project_name }}" ]; then
                        echo "‚ùå Project name is required for decrement action"
                        exit 1
                      fi

                      PROJECT_NAME="${{ github.event.inputs.project_name }}"
                      # Check if project exists
                      if ! echo "$PROJECTS_JSON" | jq -e --arg name "$PROJECT_NAME" '.projects[$name]' > /dev/null; then
                        echo "‚ùå Project '$PROJECT_NAME' not found. Cannot decrement."
                        exit 1
                      fi

                      NEW_JSON=$(echo "$PROJECTS_JSON" | jq --arg name "$PROJECT_NAME" '
                        .projects[$name].count = (.projects[$name].count - 1 | if . < 0 then 0 else . end) |
                        .projects[$name].updated_at = (now | strftime("%Y-%m-%dT%H:%M:%S.%3NZ"))
                        | {projects: .projects}
                      ')

                      NEW_COUNT=$(echo "$NEW_JSON" | jq -r --arg name "$PROJECT_NAME" '.projects[$name].count')
                      echo "‚úÖ Project '$PROJECT_NAME' decremented to count: $NEW_COUNT"
                      PROJECTS_JSON="$NEW_JSON"
                      # After decrement, compare before/after
                      if diff -q <(cat /tmp/projects_before.json) <(echo "$NEW_JSON") >/dev/null; then
                        echo "‚ùå No change detected in PROJECTS_DATA after decrement operation"
                        exit 1
                      fi
                      ;;

                    "remove")
                      if [ -z "${{ github.event.inputs.project_name }}" ]; then
                        echo "‚ùå Project name is required for remove action"
                        exit 1
                      fi

                      PROJECT_NAME="${{ github.event.inputs.project_name }}"
                      # Check if project exists
                      if ! echo "$PROJECTS_JSON" | jq -e --arg name "$PROJECT_NAME" '.projects[$name]' > /dev/null; then
                        echo "‚ùå Project '$PROJECT_NAME' not found. Cannot remove."
                        exit 1
                      fi

                      NEW_JSON=$(echo "$PROJECTS_JSON" | jq --arg name "$PROJECT_NAME" 'del(.projects[$name]) | {projects: .projects}')
                      echo "‚úÖ Project '$PROJECT_NAME' removed successfully"
                      PROJECTS_JSON="$NEW_JSON"
                      # After remove, compare before/after
                      if diff -q <(cat /tmp/projects_before.json) <(echo "$NEW_JSON") >/dev/null; then
                        echo "‚ùå No change detected in PROJECTS_DATA after remove operation"
                        exit 1
                      fi
                      ;;

                    "get")
                      if [ -z "${{ github.event.inputs.project_name }}" ]; then
                        echo "‚ùå Project name is required for get action"
                        exit 1
                      fi

                      PROJECT_NAME="${{ github.event.inputs.project_name }}"
                      sudo apt-get update && sudo apt-get install -y jq

                      PROJECT_DATA=$(echo "$PROJECTS_JSON" | jq --arg name "$PROJECT_NAME" '.projects[$name]')
                      if [ "$PROJECT_DATA" = "null" ]; then
                        echo "‚ùå Project '$PROJECT_NAME' not found"
                        exit 1
                      fi

                      echo "üìä Project Details:"
                      echo "$PROJECT_DATA" | jq .
                      ;;

                    "set")
                      if [ -z "${{ github.event.inputs.project_name }}" ]; then
                        echo "‚ùå Project name is required for set action"
                        exit 1
                      fi
                      PROJECT_NAME="${{ github.event.inputs.project_name }}"
                      # Check if project exists
                      if ! echo "$PROJECTS_JSON" | jq -e --arg name "$PROJECT_NAME" '.projects[$name]' > /dev/null; then
                        echo "‚ùå Project '$PROJECT_NAME' not found. Cannot set."
                        exit 1
                      fi
                      # If renaming, handle key change
                      if [ -n "${{ github.event.inputs.new_name }}" ] && [ "${{ github.event.inputs.new_name }}" != "$PROJECT_NAME" ]; then
                        NEW_NAME="${{ github.event.inputs.new_name }}"
                        # Copy project, update fields, delete old key, add new key
                        UPDATED_PROJECT=$(echo "$PROJECTS_JSON" | jq --arg name "$PROJECT_NAME" --arg new_name "$NEW_NAME" \
                          '.projects[$name] | .name = $new_name')
                        # Update other fields if provided
                        if [ -n "${{ github.event.inputs.description }}" ]; then
                          UPDATED_PROJECT=$(echo "$UPDATED_PROJECT" | jq --arg desc "${{ github.event.inputs.description }}" '.description = $desc')
                        fi
                        if [ -n "${{ github.event.inputs.url }}" ]; then
                          UPDATED_PROJECT=$(echo "$UPDATED_PROJECT" | jq --arg url "${{ github.event.inputs.url }}" '.url = $url')
                        fi
                        if [ -n "${{ github.event.inputs.count_value }}" ]; then
                          UPDATED_PROJECT=$(echo "$UPDATED_PROJECT" | jq --argjson count "${{ github.event.inputs.count_value }}" '.count = $count')
                        fi
                        UPDATED_PROJECT=$(echo "$UPDATED_PROJECT" | jq '.updated_at = (now | strftime("%Y-%m-%dT%H:%M:%S.%3NZ"))')
                        # Remove old key, add new key
                        NEW_JSON=$(echo "$PROJECTS_JSON" | jq --arg name "$PROJECT_NAME" --arg new_name "$NEW_NAME" --argjson updated "$UPDATED_PROJECT" '
                          .projects |= (del(.[$name]) + {($new_name): $updated}) | {projects: .}
                        ')
                      else
                        # Not renaming, just update fields
                        JQ_FILTER='.projects["'"$PROJECT_NAME"'"]'
                        if [ -n "${{ github.event.inputs.new_name }}" ]; then
                          JQ_FILTER="$JQ_FILTER | .name = \"${{ github.event.inputs.new_name }}\""
                        fi
                        if [ -n "${{ github.event.inputs.description }}" ]; then
                          JQ_FILTER="$JQ_FILTER | .description = \"${{ github.event.inputs.description }}\""
                        fi
                        if [ -n "${{ github.event.inputs.url }}" ]; then
                          JQ_FILTER="$JQ_FILTER | .url = \"${{ github.event.inputs.url }}\""
                        fi
                        if [ -n "${{ github.event.inputs.count_value }}" ]; then
                          JQ_FILTER="$JQ_FILTER | .count = ${{ github.event.inputs.count_value }}"
                        fi
                        # Always update updated_at
                        JQ_FILTER="$JQ_FILTER | .updated_at = (now | strftime(\"%Y-%m-%dT%H:%M:%S.%3NZ\"))"
                        NEW_JSON=$(echo "$PROJECTS_JSON" | jq "$JQ_FILTER" | jq '{projects: .projects}')
                      fi
                      echo "‚úÖ Project '$PROJECT_NAME' updated successfully"
                      PROJECTS_JSON="$NEW_JSON"
                      # After set, compare before/after
                      if diff -q <(cat /tmp/projects_before.json) <(echo "$NEW_JSON") >/dev/null; then
                        echo "‚ùå No change detected in PROJECTS_DATA after set operation"
                        exit 1
                      fi
                      ;;

                    "list")
                      sudo apt-get update && sudo apt-get install -y jq
                      echo "üìÇ All Projects:"
                      echo "$PROJECTS_JSON" | jq '.projects'
                      ;;
                  esac

                  # Update GitHub Variables with new data (if not get/list)
                  if [ "${{ github.event.inputs.action }}" != "list" ] && [ "${{ github.event.inputs.action }}" != "get" ]; then
                    echo "üíæ Updating GitHub Variables..."
                    # Defensive: Validate PROJECTS_JSON before encode
                    if [ -z "$PROJECTS_JSON" ] || ! echo "$PROJECTS_JSON" | jq . >/dev/null 2>&1; then
                      echo "‚ùå PROJECTS_JSON is empty or invalid before updating PROJECTS_DATA"
                      exit 1
                    fi
                    ENCODED_JSON=$(echo "$PROJECTS_JSON" | base64 -w 0)
                    if [ -z "$ENCODED_JSON" ]; then
                      echo "‚ùå Encoded JSON is empty, aborting update."
                      exit 1
                    fi
                    PATCH_RESPONSE=$(curl -s -w "\n%{http_code}" -X PATCH \
                      -H "Accept: application/vnd.github+json" \
                      -H "Authorization: Bearer ${{ secrets.PAT_TOKEN }}" \
                      -H "X-GitHub-Api-Version: 2022-11-28" \
                      "https://api.github.com/repos/${{ github.repository }}/actions/variables/PROJECTS_DATA" \
                      -d "{\"name\":\"PROJECTS_DATA\",\"value\":\"$ENCODED_JSON\"}")
                    RESPONSE_BODY=$(echo "$PATCH_RESPONSE" | head -n -1)
                    RESPONSE_CODE=$(echo "$PATCH_RESPONSE" | tail -n1)
                    if [ "$RESPONSE_CODE" -ne 200 ] && [ "$RESPONSE_CODE" -ne 204 ]; then
                      echo "‚ùå PATCH failed (HTTP $RESPONSE_CODE), response: $RESPONSE_BODY"
                      exit 1
                    fi
                    # Retry fetch up to 5 times with short sleeps
                    for i in {1..5}; do
                      response=$(curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
                        -H "Accept: application/vnd.github+json" \
                        "https://api.github.com/repos/${{ github.repository }}/actions/variables/PROJECTS_DATA" || echo "")
                      ENCODED_DATA=$(echo "$response" | grep -o '"value":"[^\"]*"' | cut -d'"' -f4)
                      PROJECTS_JSON_AFTER=$(echo "$ENCODED_DATA" | base64 -d 2>/dev/null || echo "$ENCODED_DATA" | sed 's/\\"/"/g')
                      if [ -n "$PROJECTS_JSON_AFTER" ] && echo "$PROJECTS_JSON_AFTER" | jq -e ".projects | length >= 0" >/dev/null 2>&1; then
                        break
                      fi
                      echo "‚ö†Ô∏è PROJECTS_DATA is empty after add operation, retry $i/5..."
                      sleep 5
                    done
                    if [ -z "$PROJECTS_JSON_AFTER" ] || ! echo "$PROJECTS_JSON_AFTER" | jq -e ".projects | length >= 0" >/dev/null 2>&1; then
                      echo "‚ùå PROJECTS_DATA is still empty after add operation (after retries)"
                      exit 1
                    fi
                    echo "‚úÖ Projects data updated in GitHub Variables (base64 encoded)"
                  fi

                  echo "üìä Current Projects Data:"
                  echo "$PROJECTS_JSON" | jq '.projects'
                  echo "‚úÖ GitHub Variables operations completed successfully"

            # REPOSITORY COMMITS MODE JOBS
            - name: Repository Commits - Checkout
              if: steps.mode.outputs.mode == 'repository_commits'
              uses: actions/checkout@v4
              with:
                  token: ${{ secrets.PAT_TOKEN }}

            - name: Repository Commits - Handle Operations
              if: steps.mode.outputs.mode == 'repository_commits'
              run: |
                  # Determine project name based on event type
                  if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
                    PROJECT_NAME="${{ steps.resolve.outputs.resolved_project_name }}"
                    echo "üîó Using resolved project name: $PROJECT_NAME"
                  else
                    PROJECT_NAME="${{ github.event.inputs.project_name }}"
                    echo "üìù Using manual project name: $PROJECT_NAME"
                  fi

                  # Use existing repository-based logic (from original workflow)
                  # This would be the current JSON file-based operations with commits
                  echo "üö® Repository commits mode operations need to be implemented"
                  echo "Current action: ${{ steps.inputs.outputs.action }}"
                  echo "Project: $PROJECT_NAME"

                  # For now, just show warning that repository commits mode needs implementation
                  if [ "${{ steps.inputs.outputs.action }}" != "list" ] && [ "${{ steps.inputs.outputs.action }}" != "stats" ]; then
                    echo "‚ö†Ô∏è Repository commits mode operations not yet migrated from original workflow"
                    echo "Please use database mode (STORAGE_MODE=2) or GitHub variables mode (STORAGE_MODE=1)"
                  fi


                  case "${{ steps.mode.outputs.mode }}" in
                    "database")
                      # Database analytics
                      export PGPASSWORD="${{ secrets.DB_PASS }}"
                      ANALYTICS=$(psql -h "${{ secrets.DB_HOST }}" -p "${{ secrets.DB_PORT }}" -U "${{ secrets.DB_USER }}" -d "${{ secrets.DB_NAME }}" -t -c "
                        SELECT json_build_object(
                          'total_projects', COUNT(*),
                          'total_count', COALESCE(SUM(count), 0),
                          'average_count', ROUND(COALESCE(AVG(count), 0), 2),
                          'max_count', COALESCE(MAX(count), 0),
                          'min_count', COALESCE(MIN(count), 0),
                          'last_updated', CURRENT_TIMESTAMP,
                          'storage_mode', 'database'
                        )
                        FROM ${{ secrets.DB_SCHEMA }}.projects;
                      " | xargs)
                      ;;
                    "github_variables")
                      # GitHub Variables analytics
                      sudo apt-get update && sudo apt-get install -y jq

                      # Get projects data
                      response=$(curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
                        -H "Accept: application/vnd.github+json" \
                        "https://api.github.com/repos/${{ github.repository }}/actions/variables/PROJECTS_DATA" || echo "")

                      if echo "$response" | grep -q '"value"'; then
                        ENCODED_DATA=$(echo "$response" | grep -o '"value":"[^"]*"' | cut -d'"' -f4)
                        PROJECTS_JSON=$(echo "$ENCODED_DATA" | base64 -d 2>/dev/null || echo "$ENCODED_DATA" | sed 's/\\"/"/g')

                        # Validate JSON format
                        if ! echo "$PROJECTS_JSON" | jq . >/dev/null 2>&1; then
                          PROJECTS_JSON='{"projects":{}}'
                        fi
                      else
                        PROJECTS_JSON='{"projects":{}}'
                      fi

                      TOTAL_PROJECTS=$(echo "$PROJECTS_JSON" | jq '.projects | length')
                      TOTAL_COUNT=$(echo "$PROJECTS_JSON" | jq '[.projects[].count] | add // 0')
                      AVG_COUNT=$(echo "$PROJECTS_JSON" | jq '[.projects[].count] | if length > 0 then (add / length) else 0 end | . * 100 | round / 100')
                      MAX_COUNT=$(echo "$PROJECTS_JSON" | jq '[.projects[].count] | max // 0')
                      MIN_COUNT=$(echo "$PROJECTS_JSON" | jq '[.projects[].count] | min // 0')

                      ANALYTICS=$(jq -n \
                        --argjson total_projects "$TOTAL_PROJECTS" \
                        --argjson total_count "$TOTAL_COUNT" \
                        --argjson average_count "$AVG_COUNT" \
                        --argjson max_count "$MAX_COUNT" \
                        --argjson min_count "$MIN_COUNT" \
                        --arg last_updated "$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")" \
                        --arg storage_mode "github_variables" \
                        '{
                          total_projects: $total_projects,
                          total_count: $total_count,
                          average_count: $average_count,
                          max_count: $max_count,
                          min_count: $min_count,
                          last_updated: $last_updated,
                          storage_mode: $storage_mode
                        }')
                      ;;
                    "repository_commits")
                      # Repository commits analytics (placeholder)
                      ANALYTICS='{"total_projects":0,"total_count":0,"average_count":0,"max_count":0,"min_count":0,"last_updated":"'$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")'","storage_mode":"repository_commits"}'
                      ;;
                    *)
                      # Default/unknown mode
                      ANALYTICS='{"total_projects":0,"total_count":0,"average_count":0,"max_count":0,"min_count":0,"last_updated":"'$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")'","storage_mode":"unknown"}'
                      ;;
                  esac

                  echo "üìä Analytics Generated:"
                  echo "$ANALYTICS"

                  # Store analytics as GitHub variable for frontend access
                  curl -X PATCH \
                    -H "Accept: application/vnd.github+json" \
                    -H "Authorization: Bearer ${{ secrets.PAT_TOKEN }}" \
                    -H "X-GitHub-Api-Version: 2022-11-28" \
                    "https://api.github.com/repos/${{ github.repository }}/actions/variables/ANALYTICS_DATA" \
                    -d "{\"name\":\"ANALYTICS_DATA\",\"value\":\"$ANALYTICS\"}" || \
                  curl -X POST \
                    -H "Accept: application/vnd.github+json" \
                    -H "Authorization: Bearer ${{ secrets.PAT_TOKEN }}" \
                    -H "X-GitHub-Api-Version: 2022-11-28" \
                    "https://api.github.com/repos/${{ github.repository }}/actions/variables" \
                    -d "{\"name\":\"ANALYTICS_DATA\",\"value\":\"$ANALYTICS\"}"

                  echo "‚úÖ Analytics stored in GitHub Variables"

            - name: Echo Final Projects Data
              if: always()
              run: |
                  echo "üîç Finalizing projects data summary..."
                  echo ""
                  echo "===== FINAL PROJECTS DATA SUMMARY ====="
                  MODE="${{ steps.mode.outputs.mode }}"
                  if [ "$MODE" = "database" ]; then
                    export PGPASSWORD="${{ secrets.DB_PASS }}"
                    if psql -h "${{ secrets.DB_HOST }}" -p "${{ secrets.DB_PORT }}" -U "${{ secrets.DB_USER }}" -d "${{ secrets.DB_NAME }}" -c "\dt" > /dev/null 2>&1; then
                      echo "Database connection successful. Showing up to 20 most recently updated projects:"
                      psql -h "${{ secrets.DB_HOST }}" -p "${{ secrets.DB_PORT }}" -U "${{ secrets.DB_USER }}" -d "${{ secrets.DB_NAME }}" -c "SELECT name, description, url, alias, count, updated_at FROM ${{ secrets.DB_SCHEMA }}.projects ORDER BY updated_at DESC LIMIT 20;"
                    else
                      echo "‚ùå Database not connected or credentials invalid."
                    fi
                  elif [ "$MODE" = "github_variables" ]; then
                    response=$(curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
                      -H "Accept: application/vnd.github+json" \
                      "https://api.github.com/repos/${{ github.repository }}/actions/variables/PROJECTS_DATA" || echo "")
                    if echo "$response" | grep -q '"value"'; then
                      ENCODED_DATA=$(echo "$response" | grep -o '"value":"[^\"]*"' | cut -d'"' -f4)
                      PROJECTS_JSON=$(echo "$ENCODED_DATA" | base64 -d 2>/dev/null || echo "$ENCODED_DATA" | sed 's/\\"/"/g')
                      echo "Raw projects object (for debugging):"
                      echo "$PROJECTS_JSON" | jq '.projects'
                      echo "Showing up to 20 most recently updated projects (if available):"
                      SORTED=$(echo "$PROJECTS_JSON" | jq '.projects | to_entries | sort_by(-.value.updated_at) | .[:20] | map({name: .key} + .value)')
                      if [ "$SORTED" = "null" ] || [ "$SORTED" = "[]" ]; then
                        echo "No projects with updated_at found or invalid sort. Showing first 20 projects as-is:"
                        echo "$PROJECTS_JSON" | jq '.projects | to_entries | .[:20] | map({name: .key} + .value)'
                      else
                        echo "$SORTED"
                      fi
                    else
                      echo "‚ùå PROJECTS_DATA variable is empty or not found."
                    fi
                  else
                    echo "‚ö†Ô∏è Storage mode is unknown or not supported for summary."
                  fi
                  echo "===== END OF PROJECTS DATA SUMMARY =====\n"
